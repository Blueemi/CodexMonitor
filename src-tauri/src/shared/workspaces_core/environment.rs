use std::path::{Path, PathBuf};

use serde::{Deserialize, Serialize};

use crate::types::{LaunchScriptEntry, WorkspaceSettings};

const ENV_RELATIVE_PATH: &str = ".codex/environments/environment.toml";
const ENV_DEFAULT_VERSION: u32 = 1;
const ENV_HEADER_COMMENT: &str = "# THIS IS AUTOGENERATED. DO NOT EDIT MANUALLY\n";
const DEFAULT_ACTION_ICON: &str = "play";

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
struct EnvironmentToml {
    #[serde(default)]
    version: Option<u32>,
    #[serde(default)]
    name: Option<String>,
    #[serde(default)]
    setup: Option<EnvironmentSetupToml>,
    #[serde(default)]
    actions: Vec<EnvironmentActionToml>,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
struct EnvironmentSetupToml {
    #[serde(default)]
    script: Option<String>,
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
struct EnvironmentActionToml {
    #[serde(default)]
    id: Option<String>,
    #[serde(default)]
    name: Option<String>,
    #[serde(default)]
    icon: Option<String>,
    #[serde(default, alias = "script")]
    command: Option<String>,
}

fn environment_path_for_workspace(workspace_root: &Path) -> PathBuf {
    workspace_root.join(ENV_RELATIVE_PATH)
}

fn normalize_icon(value: Option<&str>) -> String {
    match value {
        Some(icon) if !icon.trim().is_empty() => icon.trim().to_string(),
        _ => DEFAULT_ACTION_ICON.to_string(),
    }
}

fn read_environment_doc(path: &Path) -> Result<Option<EnvironmentToml>, String> {
    if !path.is_file() {
        return Ok(None);
    }
    let contents = std::fs::read_to_string(path)
        .map_err(|err| format!("Failed to read environment.toml: {err}"))?;
    let parsed: EnvironmentToml = toml::from_str(&contents)
        .map_err(|err| format!("Failed to parse environment.toml: {err}"))?;
    Ok(Some(parsed))
}

fn scripts_from_doc(doc: &EnvironmentToml) -> Vec<LaunchScriptEntry> {
    let mut scripts = Vec::new();
    for (index, action) in doc.actions.iter().enumerate() {
        let command = action.command.clone().unwrap_or_default();
        if command.trim().is_empty() {
            continue;
        }
        let id = action
            .id
            .as_ref()
            .map(|value| value.trim())
            .filter(|value| !value.is_empty())
            .map(ToString::to_string)
            .unwrap_or_else(|| format!("environment-action-{}", index + 1));
        let label = action
            .name
            .as_ref()
            .map(|value| value.trim())
            .filter(|value| !value.is_empty())
            .map(ToString::to_string);
        scripts.push(LaunchScriptEntry {
            id,
            script: command,
            icon: normalize_icon(action.icon.as_deref()),
            label,
        });
    }
    scripts
}

fn actions_from_scripts(scripts: &[LaunchScriptEntry]) -> Vec<EnvironmentActionToml> {
    let mut actions = Vec::new();
    for (index, script) in scripts.iter().enumerate() {
        if script.script.trim().is_empty() {
            continue;
        }
        let name = script
            .label
            .as_ref()
            .map(|value| value.trim())
            .filter(|value| !value.is_empty())
            .map(ToString::to_string)
            .unwrap_or_else(|| format!("Action {}", index + 1));
        actions.push(EnvironmentActionToml {
            id: None,
            name: Some(name),
            icon: Some(normalize_icon(Some(&script.icon))),
            command: Some(script.script.clone()),
        });
    }
    actions
}

pub(crate) fn launch_scripts_changed(
    previous: &WorkspaceSettings,
    next: &WorkspaceSettings,
) -> bool {
    previous.launch_script != next.launch_script || previous.launch_scripts != next.launch_scripts
}

pub(crate) fn load_workspace_launch_scripts(
    workspace_root: &Path,
    fallback_settings: &WorkspaceSettings,
) -> (Option<String>, Option<Vec<LaunchScriptEntry>>) {
    let environment_path = environment_path_for_workspace(workspace_root);
    let parsed = match read_environment_doc(&environment_path) {
        Ok(value) => value,
        Err(error) => {
            eprintln!(
                "list_workspaces: failed reading {}: {}",
                environment_path.display(),
                error
            );
            return (
                fallback_settings.launch_script.clone(),
                fallback_settings.launch_scripts.clone(),
            );
        }
    };

    let Some(doc) = parsed else {
        return (
            fallback_settings.launch_script.clone(),
            fallback_settings.launch_scripts.clone(),
        );
    };

    let scripts = scripts_from_doc(&doc);
    let launch_script = scripts.first().map(|entry| entry.script.clone());
    (launch_script, Some(scripts))
}

pub(crate) fn persist_workspace_launch_scripts(
    workspace_root: &Path,
    settings: &WorkspaceSettings,
) -> Result<(), String> {
    let environment_path = environment_path_for_workspace(workspace_root);

    let mut scripts = settings.launch_scripts.clone().unwrap_or_default();
    if scripts.is_empty() {
        if let Some(command) = settings
            .launch_script
            .as_ref()
            .map(|value| value.trim())
            .filter(|value| !value.is_empty())
        {
            scripts.push(LaunchScriptEntry {
                id: "launch-default".to_string(),
                script: command.to_string(),
                icon: DEFAULT_ACTION_ICON.to_string(),
                label: Some("Launch".to_string()),
            });
        }
    }

    let mut doc = read_environment_doc(&environment_path)?.unwrap_or_default();
    if doc.version.is_none() {
        doc.version = Some(ENV_DEFAULT_VERSION);
    }
    doc.actions = actions_from_scripts(&scripts);

    let serialized = toml::to_string_pretty(&doc)
        .map_err(|err| format!("Failed to encode environment.toml: {err}"))?;
    let parent = environment_path
        .parent()
        .ok_or_else(|| "Invalid environment.toml path".to_string())?;
    std::fs::create_dir_all(parent)
        .map_err(|err| format!("Failed to create environment directory: {err}"))?;
    std::fs::write(
        &environment_path,
        format!("{ENV_HEADER_COMMENT}{serialized}"),
    )
    .map_err(|err| format!("Failed to write environment.toml: {err}"))?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use std::path::PathBuf;

    use uuid::Uuid;

    use crate::types::{LaunchScriptEntry, WorkspaceSettings};

    use super::{load_workspace_launch_scripts, persist_workspace_launch_scripts};

    fn temp_dir() -> PathBuf {
        let dir =
            std::env::temp_dir().join(format!("codex-monitor-environment-{}", Uuid::new_v4()));
        std::fs::create_dir_all(&dir).expect("create temp dir");
        dir
    }

    #[test]
    fn reads_actions_from_environment_file() {
        let root = temp_dir();
        let env_path = root.join(".codex/environments/environment.toml");
        std::fs::create_dir_all(env_path.parent().expect("parent")).expect("create env dir");
        std::fs::write(
            &env_path,
            "version = 1\n[[actions]]\nname = \"Run\"\nicon = \"run\"\ncommand = \"npm run dev\"\n",
        )
        .expect("write env file");

        let fallback = WorkspaceSettings::default();
        let (launch_script, launch_scripts) = load_workspace_launch_scripts(&root, &fallback);

        assert_eq!(launch_script.as_deref(), Some("npm run dev"));
        let scripts = launch_scripts.expect("scripts should be present");
        assert_eq!(scripts.len(), 1);
        assert_eq!(scripts[0].label.as_deref(), Some("Run"));
        assert_eq!(scripts[0].icon, "run");
        assert_eq!(scripts[0].script, "npm run dev");

        let _ = std::fs::remove_dir_all(root);
    }

    #[test]
    fn writes_actions_into_environment_file() {
        let root = temp_dir();
        let settings = WorkspaceSettings {
            launch_script: None,
            launch_scripts: Some(vec![
                LaunchScriptEntry {
                    id: "one".to_string(),
                    script: "npm run dev".to_string(),
                    icon: "play".to_string(),
                    label: Some("Run".to_string()),
                },
                LaunchScriptEntry {
                    id: "two".to_string(),
                    script: "npm run test".to_string(),
                    icon: "test".to_string(),
                    label: Some("Tests".to_string()),
                },
            ]),
            ..WorkspaceSettings::default()
        };

        persist_workspace_launch_scripts(&root, &settings).expect("persist scripts");
        let written = std::fs::read_to_string(root.join(".codex/environments/environment.toml"))
            .expect("read environment file");

        assert!(written.contains("[[actions]]"));
        assert!(written.contains("name = \"Run\""));
        assert!(written.contains("command = \"npm run dev\""));
        assert!(written.contains("name = \"Tests\""));
        assert!(written.contains("command = \"npm run test\""));

        let _ = std::fs::remove_dir_all(root);
    }
}
